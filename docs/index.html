<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ark – Matterport (Web Component)</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#111; color:#eee; }
    matterport-viewer { display:block; inline-size:100%; block-size:100dvh; }
    .badge {
      position:absolute; left:10px; top:10px; z-index:5;
      padding:6px 10px; font:12px system-ui;
      background:rgba(0,0,0,.55); border:1px solid #333; border-radius:8px;
    }
  </style>

  <!-- Local showcase CSS (no CDN) -->
  <link rel="stylesheet" href="./css/showcase.css" />

  <!-- Import map: resolve "three" to your local ESM build -->
  <script type="importmap">
  {
    "imports": {
      "three": "./vendors/three/0.176.0/build/three.module.js",
      "three/addons/": "./vendors/three/0.176.0/examples/jsm/",
      "@matterport/webcomponent": "./vendors/matterport-webcomponent/0.1.45/matterport-viewer.esm.js"
    }
  }
  </script>
</head>
<body>
  <div class="badge" id="badge">loading…</div>

  <!-- Keep it minimal -->
  <matterport-viewer
    m="1ghABoaBFPZ"
    application-key="akqd0dp3hr9wz4eu70zd1rsab"
    asset-base="/Ark"
    play title="false" brand="false" style="outline:0">
  </matterport-viewer>

  <script type="module">
    // Load the ESM web component via the import map
    import "@matterport/webcomponent";

    const badge  = document.getElementById('badge');
    const viewer = document.querySelector('matterport-viewer');

    // Helpful diagnostics
    const log = (e) => console.log(`[${e.type}]`, e.detail ?? '');
    ['mpReady','mpProgress','mpCameraAvailable','mpNavigationChanged','mpError','mpSdkError']
      .forEach(t => viewer.addEventListener(t, log));

    // --- SecurityCam Scene Component (uses the THREE supplied by the SDK context) ---
    function registerSecurityCam(sdk) {
      sdk.Scene.register("ark.securityCam", () => {
        return class SecurityCam extends sdk.Scene.Component {
          constructor(ctx) {
            super(ctx);
            this.inputs = {
              near: 0.30, far: 12.0, hfovDeg: 90, aspect: 16/9,
              color: 0x00aaff, opacity: 0.18, wireOpacity: 0.60,
              worldPosition: { x: 0, y: 2.6, z: 0 },
              worldRotationQuat: null,
              worldEulerDeg: { x: 0, y: 0, z: 0 },
              panEnabled: false, panAngleDeg: 60, panPeriodSec: 8
            };
            this.outputs = { objectRoot: null };
            this._t = 0;
          }

          onInit() {
            const T = this.context.three;
            this.root  = new T.Group();
            this.yaw   = new T.Group();
            this.pitch = new T.Group();
            this.root.add(this.yaw);
            this.yaw.add(this.pitch);

            this.material = new T.MeshBasicMaterial({
              color: this.inputs.color, transparent: true,
              opacity: this.inputs.opacity, depthWrite: false, side: T.DoubleSide
            });
            this.lineMat = new T.LineBasicMaterial({
              color: this.inputs.color, transparent: true, opacity: this.inputs.wireOpacity
            });

            this._buildFrustum();
            this._applyTransform();
            this.outputs.objectRoot = this.root;
          }

          _buildFrustum() {
            const T = this.context.three;
            const n=this.inputs.near, f=this.inputs.far;
            const hf=T.MathUtils.degToRad(this.inputs.hfovDeg);
            const a=this.inputs.aspect, vf=2*Math.atan(Math.tan(hf/2)/a);

            const nw=Math.tan(hf/2)*n, nh=Math.tan(vf/2)*n;
            const fw=Math.tan(hf/2)*f, fh=Math.tan(vf/2)*f;

            const V=[[-nw,nh,-n],[nw,nh,-n],[nw,-nh,-n],[-nw,-nh,-n],
                     [-fw,fh,-f],[fw,fh,-f],[fw,-fh,-f],[-fw,-fh,-f]];

            const idx=[0,1,2,0,2,3, 4,6,5,4,7,6, 0,4,5,0,5,1, 1,5,6,1,6,2, 2,6,7,2,7,3, 3,7,4,3,4,0];
            const pos=new Float32Array(idx.length*3);
            for(let i=0;i<idx.length;i++){const p=V[idx[i]];pos[i*3]=p[0];pos[i*3+1]=p[1];pos[i*3+2]=p[2];}
            const g=new T.BufferGeometry(); g.setAttribute("position", new T.BufferAttribute(pos,3));

            const ep=[0,1,1,2,2,3,3,0, 4,5,5,6,6,7,7,4, 0,4,1,5,2,6,3,7];
            const epos=new Float32Array(ep.length*3);
            for(let i=0;i<ep.length;i++){const p=V[ep[i]];epos[i*3]=p[0];epos[i*3+1]=p[1];epos[i*3+2]=p[2];}
            const eg=new T.BufferGeometry(); eg.setAttribute("position", new T.BufferAttribute(epos,3));

            if(!this.mesh){
              this.mesh=new T.Mesh(g,this.material);
              this.wire=new T.LineSegments(eg,this.lineMat);
              this.pitch.add(this.mesh,this.wire);
            } else {
              this.mesh.geometry?.dispose(); this.wire.geometry?.dispose();
              this.mesh.geometry=g; this.wire.geometry=eg;
            }
          }

          _applyTransform() {
            const T=this.context.three;
            this.root.position.set(this.inputs.worldPosition.x,this.inputs.worldPosition.y,this.inputs.worldPosition.z);
            if(this.inputs.worldRotationQuat && "x" in this.inputs.worldRotationQuat){
              const q=this.inputs.worldRotationQuat;
              this.root.quaternion.set(q.x,q.y,q.z,q.w);
            } else {
              const e=this.inputs.worldEulerDeg;
              this.root.rotation.set(
                T.MathUtils.degToRad(e.x||0),
                T.MathUtils.degToRad(e.y||0),
                T.MathUtils.degToRad(e.z||0),
                "YXZ"
              );
            }
            this.yaw.rotation.set(0,0,0);
            this.pitch.rotation.set(0,0,0);
          }

          onInputsChanged(changed){
            if(changed.near||changed.far||changed.hfovDeg||changed.aspect) this._buildFrustum();
            if(changed.worldPosition||changed.worldRotationQuat||changed.worldEulerDeg) this._applyTransform();
          }

          onTick(dt){
            if(!this.inputs.panEnabled) return;
            const T=this.context.three, amp=T.MathUtils.degToRad(this.inputs.panAngleDeg||60);
            const omega=(2*Math.PI)/(this.inputs.panPeriodSec||8);
            this.yaw.rotation.y=Math.sin((this._t+=dt)*omega)*amp;
          }
        };
      });
    }

    // Helper to spawn a camera frustum at the current viewer pose
    async function addCamAtViewer(sdk, opts = {}) {
      const pose = await sdk.Camera.getPose();
      const node = await sdk.Scene.createNode();
      const comp = node.addComponent("ark.securityCam");
      const defaults = {
        worldPosition: { ...pose.position },
        worldRotationQuat: { ...pose.rotation },
        hfovDeg: 90, aspect: 16/9, near: 0.3, far: 12,
        color: 0x00aaff, opacity: 0.18, wireOpacity: 0.6,
        panEnabled: false
      };
      const updates = Object.assign(defaults, opts);
      if (comp.inputs?.set) comp.inputs.set(updates); else Object.assign(comp.inputs, updates);
      await node.start();
      console.log("security cam added", node.id);
      return node.id;
    }
    // ------------------------------------------------------------------------------

    // SDK
    viewer.addEventListener('mpSdkPlaying', async (evt) => {
      try {
        const sdk = evt.detail.mpSdk;

        // Register the component and spawn one at the current pose
        registerSecurityCam(sdk);
        await addCamAtViewer(sdk, { hfovDeg: 90 });

        const info = await sdk.Model.getData();
        badge.textContent = `SDK connected — model: ${info.sid}`;
        console.log('pose', await sdk.Camera.getPose());
      } catch (err) {
        console.error('SDK init error', err);
        badge.textContent = 'SDK init error (see console)';
      }
    });

    // Timeout notice if nothing happens
    setTimeout(() => {
      if (badge.textContent.startsWith('loading')) {
        console.warn('Viewer did not reach READY/PLAYING in time');
        badge.textContent = 'still loading… (check console/network)';
      }
    }, 10000);
  </script>
</body>
</html>