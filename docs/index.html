<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ark – Matterport (Web Component)</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#111; color:#eee; }
    matterport-viewer { display:block; inline-size:100%; block-size:100dvh; }
    .badge {
      position:absolute; left:10px; top:10px; z-index:5;
      padding:6px 10px; font:12px system-ui;
      background:rgba(0,0,0,.55); border:1px solid #333; border-radius:8px;
    }
  </style>

  <!-- Local showcase CSS -->
  <link rel="stylesheet" href="./css/showcase.css" />

  <!-- Import map (valid JSON only) -->
  <script type="importmap">
  {
    "imports": {
      "three": "./vendors/three/0.176.0/build/three.module.js",
      "three/addons/": "./vendors/three/0.176.0/examples/jsm/",
      "@matterport/webcomponent": "./vendors/matterport-webcomponent/0.1.45/matterport-viewer.esm.js"
    }
  }
  </script>
</head>
<body>
  <div class="badge" id="badge">loading…</div>

  <matterport-viewer
    m="1ghABoaBFPZ"
    application-key="akqd0dp3hr9wz4eu70zd1rsab"
    asset-base="/Ark"
    play title="false" brand="false" style="outline:0">
  </matterport-viewer>

  <script type="module">
  import "@matterport/webcomponent";

  const badge  = document.getElementById('badge');
  const viewer = document.querySelector('matterport-viewer');
  const set = (t) => (badge.textContent = t);

  // Tweakables
  const FOLLOW_CAMERA = true;     // make the wedge follow you as you move
  const WEDGE_SCALE   = 0.55;     // overall size (uniform)
  const HEIGHT_OFFSET = 0.00;     // raise/lower the wedge in meters

  // If your GLB's forward axis isn't +Z, set a fixed local correction here.
  // Examples:
  //  - GLB forward is +Y  -> rotate +90° around X  => [ +90, 0, 0 ]
  //  - GLB forward is -Z  -> rotate 180° around Y  => [ 0, 180, 0 ]
  //  - GLB forward is +X  -> rotate -90° around Y  => [ 0, -90, 0 ]
  const AXIS_CORRECTION_EULER_DEG = [0, 0, 0]; // [xDeg, yDeg, zDeg]

  // --- small vector/quaternion helpers (no THREE import needed) ---
  const V = (x=0,y=0,z=0) => ({x:Number(x)||0,y:Number(y)||0,z:Number(z)||0});
  const len = (v)=>Math.hypot(v.x,v.y,v.z)||1;
  const norm = (v)=>{ const s = 1/len(v); return {x:v.x*s,y:v.y*s,z:v.z*s}; };
  const dot = (a,b)=>a.x*b.x+a.y*b.y+a.z*b.z;
  const cross = (a,b)=>({x:a.y*b.z-a.z*b.y,y:a.z*b.x-a.x*b.z,z:a.x*b.y-a.y*b.x});
  const qMul = (a,b)=>({ // quaternion multiply a*b
    w:a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
    x:a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
    y:a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
    z:a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w
  });
  const qNorm = (q)=>{ const s=1/Math.hypot(q.x,q.y,q.z,q.w||0); return {x:q.x*s,y:q.y*s,z:q.z*s,w:(q.w||0)*s}; };
  const qFromEulerDeg = ([ex,ey,ez])=>{
    const toRad = Math.PI/180; const cx=Math.cos(ex*toRad*0.5), sx=Math.sin(ex*toRad*0.5);
    const cy=Math.cos(ey*toRad*0.5), sy=Math.sin(ey*toRad*0.5);
    const cz=Math.cos(ez*toRad*0.5), sz=Math.sin(ez*toRad*0.5);
    return {
      w: cx*cy*cz + sx*sy*sz,
      x: sx*cy*cz - cx*sy*sz,
      y: cx*sy*cz + sx*cy*sz,
      z: cx*cy*sz - sx*sy*cz
    };
  };
  // Quaternion rotating unit +Z -> unit 't'
  function quatFromZTo(t){
    const a = V(0,0,1), b = norm(t);
    let v = cross(a,b); let w = 1 + dot(a,b);
    if (w < 1e-6) { // opposite; pick any orthogonal axis
      v = Math.abs(a.z) < 0.9 ? cross(a,{x:1,y:0,z:0}) : cross(a,{x:0,y:1,z:0});
      w = 0;
    }
    return qNorm({x:v.x,y:v.y,z:v.z,w});
  }

  // Tag fallback for when GLB can't be fetched
  async function addCamTagFallback(sdk) {
    const pose = await sdk.Camera.getPose();
    const p = { x: +pose.position.x, y: +pose.position.y, z: +pose.position.z };
    const shapes = [
      { label:'Cam', description:'Fallback marker (GLB missing)', anchorPosition: p, stemVector:{x:0,y:0.2,z:0} },
      { label:'Cam', description:'Fallback marker (GLB missing)', position: p,        normal:{x:0,y:1,z:0} }
    ];
    for (const d of shapes) {
      try { await sdk.Tag.add([d]); return; } catch {}
    }
    throw new Error('Tag.add fallback failed');
  }

  let wedgeNode = null;
  async function placeOrUpdateWedge(sdk, pose){
    if (!wedgeNode) {
      wedgeNode = await sdk.Scene.createNode();
      const bust = 'ark-wedge-v1';
      const url = new URL(`./assets/ark-wedge.glb?${bust}`, import.meta.url).href;
      // Use built-in GLTF loader (factory id string)
      wedgeNode.addComponent('mp.gltfLoader', { url });
      wedgeNode.scale.set(WEDGE_SCALE, WEDGE_SCALE, WEDGE_SCALE);
      wedgeNode.start();
    }
    // Position at camera (optionally offset height)
    wedgeNode.position.set(pose.position.x, pose.position.y + HEIGHT_OFFSET, pose.position.z);

    // Aim +Z of the GLB toward camera forward and apply fixed axis correction
    const f = V(pose.forward.x, pose.forward.y, pose.forward.z);
    const qAim = quatFromZTo(f);
    const qFix = qFromEulerDeg(AXIS_CORRECTION_EULER_DEG);
    const q = qNorm( qMul(qAim, qFix) );
    wedgeNode.quaternion.set(q.x, q.y, q.z, q.w);
  }

  ['mpReady','mpPlaying','mpError','mpSdkError']
    .forEach(ev => viewer.addEventListener(ev, e => console.log(`[${ev}]`, e.detail ?? null)));

  viewer.addEventListener('mpSdkPlaying', async (evt) => {
    const sdk = evt.detail?.mpSdk;
    if (!sdk) { set('SDK missing'); return; }

    try {
      const pose = await sdk.Camera.getPose();
      await placeOrUpdateWedge(sdk, pose);
      set('SDK ✓ 3D cam (GLB) added');

      if (FOLLOW_CAMERA) {
        viewer.addEventListener('mpNavigationChanged', async () => {
          try { await placeOrUpdateWedge(sdk, await sdk.Camera.getPose()); }
          catch (e) { console.warn('update wedge failed', e); }
        });
      }
    } catch (e) {
      console.warn('GLB path failed; Tag fallback', e);
      try { await addCamTagFallback(sdk); set('SDK ✓ tag added (fallback)'); }
      catch (e2) { set('SDK init error (see console)'); console.error(e2); }
    }
  });

  setTimeout(() => {
    if (badge.textContent.startsWith('loading')) {
      console.warn('Viewer did not reach READY/PLAYING in time');
      badge.textContent = 'still loading… (check console/network)';
    }
  }, 10000);
</script>
</body>
</html>