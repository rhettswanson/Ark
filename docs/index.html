<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Security Camera FOV in Matterport</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
  <iframe id="showcase" width="100%" height="100%" src="bundle/showcase.html?m=1ghABoaBFPZ&applicationKey=akqd0dp3hr9wz4eu70zd1rsab" frameborder="0" allowfullscreen allow="xr-spatial-tracking"></iframe>
  <script>
  (async () => {
    const showcase = document.getElementById('showcase');
    showcase.addEventListener('load', async () => {
      try {
        const mpSdk = await showcase.contentWindow.MP_SDK.connect(showcase.contentWindow);
        console.log('SDK Connected:', mpSdk);

        // Log Mattertags for position
        mpSdk.Tag.data.subscribe({
          onCollectionUpdated: function (collection) {
            console.log('Mattertags:', collection);
          }
        });

        const THREE = showcase.contentWindow.THREE;

        mpSdk.Scene.register('mp.securityCamera', function () {
          return {
            name: 'mp.securityCamera',
            inputs: {
              nearPlane: 0.3,
              farPlane: 30.48, // 100 feet
              horizontalFOV: 100,
              aspect: 100 / 60, // Vertical 60Â° assumption
              localPosition: { x: 0, y: 1.5, z: 0 }, // Placeholder, update with Mattertag
              localRotation: { x: -20, y: 0, z: 0 }, // Tilt down
              color: 0x00ff00, // Green
              panPeriod: 8,
              panAngle: 120
            },
            outputs: {},
            onInit: function () {
              const T = this.context.three;
              this.group = new T.Group();
              this.yaw = new T.Group();
              this.pitch = new T.Group();
              this.group.add(this.yaw);
              this.yaw.add(this.pitch);
              this._buildFrustum();
              this.outputs.objectRoot = this.group;
              this._applyTransform();
              this._makeAnimation();
            },
            onEvent: function (event) {
              if (event === mpSdk.Scene.SceneEventType.UPDATE) {
                this._update();
              }
            },
            onInputsUpdated: function () {
              this._rebuildFrustum();
              this._applyTransform();
            },
            onDestroy: function () {
              this.mesh.geometry.dispose();
              this.mesh.material.dispose();
              this.footprint.geometry.dispose();
              this.footprint.material.dispose();
            },
            _buildFrustum: function () {
              const T = this.context.three;
              const hFov = this.inputs.horizontalFOV * (Math.PI / 180);
              const aspect = this.inputs.aspect;
              const near = this.inputs.nearPlane;
              const far = Math.max(near + 0.01, this.inputs.farPlane);
              const nearR = Math.tan(hFov / 2) * near;
              const farR = Math.tan(hFov / 2) * far;
              const geom = new T.CylinderGeometry(nearR, farR, far - near, 48, 1, true);
              geom.translate(0, (far - near) / 2, 0);
              geom.rotateX(Math.PI / 2);
              const mat = new T.MeshBasicMaterial({
                color: this.inputs.color,
                transparent: true,
                opacity: 0.35,
                depthWrite: false
              });
              const frustum = new T.Mesh(geom, mat);
              frustum.scale.x = aspect;
              this.mesh = frustum;
              const footprintGeometry = new T.CircleGeometry(farR * aspect, 64);
              footprintGeometry.rotateX(-Math.PI / 2);
              const footprintMaterial = new T.MeshBasicMaterial({ color: this.inputs.color, opacity: 0.25, transparent: true, side: T.DoubleSide });
              this.footprint = new T.Mesh(footprintGeometry, footprintMaterial);
              this.pitch.add(this.mesh);
              this.pitch.add(this.footprint);
            },
            _rebuildFrustum: function () {
              this.pitch.remove(this.mesh);
              this.pitch.remove(this.footprint);
              this._buildFrustum();
            },
            _update: function () {
              if (this.mixer) this.mixer.update(1 / 60);
            },
            _applyTransform: function () {
              this.group.position.set(this.inputs.localPosition.x, this.inputs.localPosition.y, this.inputs.localPosition.z);
              this.group.rotation.set(this.inputs.localRotation.x, this.inputs.localRotation.y, this.inputs.localRotation.z);
            },
            _makeAnimation: function () {
              const T = this.context.three;
              const yAxis = new T.Vector3(0, 1, 0);
              const frame0 = new T.Quaternion().setFromAxisAngle(yAxis, 0);
              const frame1 = new T.Quaternion().setFromAxisAngle(yAxis, this.inputs.panAngle * (Math.PI / 180));
              const track = new T.QuaternionKeyframeTrack(
                '.rotation',
                [0, this.inputs.panPeriod * 0.05, this.inputs.panPeriod * 0.95, this.inputs.panPeriod],
                [
                  frame0.x, frame0.y, frame0.z, frame0.w,
                  frame0.x, frame0.y, frame0.z, frame0.w,
                  frame1.x, frame1.y, frame1.z, frame1.w,
                  frame1.x, frame1.y, frame1.z, frame1.w,
                ]
              );
              const clip = new T.AnimationClip('panning', this.inputs.panPeriod, [track]);
              this.mixer = new T.AnimationMixer(this.yaw);
              const action = this.mixer.clipAction(clip);
              action.loop = T.LoopPingPong;
              action.play();
            }
          };
        });

        const [sceneObject] = await mpSdk.Scene.createObjects(1);
        const node = sceneObject.addNode();

        node.addComponent('mp.securityCamera');

        node.start();

        console.log('FOV cone added!');
      } catch (e) {
        console.error('Error:', e);
      }
    });
  })();
</script>
</body>
</html>