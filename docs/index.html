<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ark – Matterport (Web Component)</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#111; color:#eee; }
    matterport-viewer { display:block; inline-size:100%; block-size:100dvh; }
    .badge {
      position:absolute; left:10px; top:10px; z-index:5;
      padding:6px 10px; font:12px system-ui;
      background:rgba(0,0,0,.55); border:1px solid #333; border-radius:8px;
    }
  </style>

  <!-- Local Showcase CSS -->
  <link rel="stylesheet" href="./css/showcase.css" />

  <!-- Import map to local copies -->
  <script type="importmap">
  {
    "imports": {
      "three": "./vendors/three/0.176.0/build/three.module.js",
      "three/addons/": "./vendors/three/0.176.0/examples/jsm/",
      "@matterport/webcomponent": "./vendors/matterport-webcomponent/0.1.45/matterport-viewer.esm.js"
    }
  }
  </script>
</head>
<body>
  <div class="badge" id="badge">loading…</div>

  <matterport-viewer
    m="1ghABoaBFPZ"
    application-key="akqd0dp3hr9wz4eu70zd1rsab"
    asset-base="/Ark"
    play title="false" brand="false" style="outline:0">
  </matterport-viewer>

  <script type="module">
    import "@matterport/webcomponent";

    const badge  = document.getElementById('badge');
    const viewer = document.querySelector('matterport-viewer');

    // ---------- SecurityCam Scene Component ----------
    function registerSecurityCam(sdk) {
      class SecurityCam extends sdk.Scene.Component {
        // Keep defaults as class fields (SDK looks for an object here)
        inputs = {
          near: 0.30, far: 12.0, hfovDeg: 95, aspect: 16/9,
          color: 0xff44aa, opacity: 0.28, wireOpacity: 0.9,
          worldPosition: { x: 0, y: 2.6, z: 0 },
          worldRotationQuat: null,
          worldEulerDeg: { x: 0, y: 0, z: 0 },
          panEnabled: false, panAngleDeg: 60, panPeriodSec: 8
        };
        outputs = { objectRoot: null };

        onInit() {
          const T = this.context.three;

          this.root  = new T.Group();
          this.root.renderOrder = 9999; // draw last (always on top)
          this.yaw   = new T.Group();
          this.pitch = new T.Group();
          this.root.add(this.yaw);
          this.yaw.add(this.pitch);

          this.material = new T.MeshBasicMaterial({
            color: this.inputs.color,
            transparent: true,
            opacity: this.inputs.opacity,
            side: T.DoubleSide,
            depthWrite: false,
            depthTest: false
          });
          this.lineMat = new T.LineBasicMaterial({
            color: this.inputs.color,
            transparent: true,
            opacity: this.inputs.wireOpacity,
            depthTest: false
          });

          this._buildFrustum();
          this._applyTransform();
          this.outputs.objectRoot = this.root;
          this._t = 0;
        }

        _buildFrustum() {
          const T = this.context.three;
          const n=this.inputs.near, f=this.inputs.far;
          const hf=T.MathUtils.degToRad(this.inputs.hfovDeg);
          const a=this.inputs.aspect, vf=2*Math.atan(Math.tan(hf/2)/a);

          const nw=Math.tan(hf/2)*n, nh=Math.tan(vf/2)*n;
          const fw=Math.tan(hf/2)*f, fh=Math.tan(vf/2)*f;

          const V=[[-nw,nh,-n],[nw,nh,-n],[nw,-nh,-n],[-nw,-nh,-n],
                   [-fw,fh,-f],[fw,fh,-f],[fw,-fh,-f],[-fw,-fh,-f]];

          const tris=[0,1,2,0,2,3, 4,6,5,4,7,6, 0,4,5,0,5,1, 1,5,6,1,6,2,
                      2,6,7,2,7,3, 3,7,4,3,4,0];
          const tp=new Float32Array(tris.length*3);
          for(let i=0;i<tris.length;i++){const p=V[tris[i]];tp[i*3]=p[0];tp[i*3+1]=p[1];tp[i*3+2]=p[2];}
          const g=new T.BufferGeometry(); g.setAttribute("position", new T.BufferAttribute(tp,3));

          const ep=[0,1,1,2,2,3,3,0, 4,5,5,6,6,7,7,4, 0,4,1,5,2,6,3,7];
          const epos=new Float32Array(ep.length*3);
          for(let i=0;i<ep.length;i++){const p=V[ep[i]];epos[i*3]=p[0];epos[i*3+1]=p[1];epos[i*3+2]=p[2];}
          const eg=new T.BufferGeometry(); eg.setAttribute("position", new T.BufferAttribute(epos,3));

          if(!this.mesh){
            this.mesh=new T.Mesh(g,this.material);
            this.wire=new T.LineSegments(eg,this.lineMat);
            this.pitch.add(this.mesh,this.wire);
          }else{
            this.mesh.geometry?.dispose(); this.wire.geometry?.dispose();
            this.mesh.geometry=g; this.wire.geometry=eg;
          }
        }

        _applyTransform() {
          const T=this.context.three;
          const wp = this.inputs.worldPosition;
          this.root.position.set(wp.x, wp.y, wp.z);

          if (this.inputs.worldRotationQuat && "x" in this.inputs.worldRotationQuat) {
            const q=this.inputs.worldRotationQuat;
            this.root.quaternion.set(q.x,q.y,q.z,q.w);
          } else {
            const e=this.inputs.worldEulerDeg;
            this.root.rotation.set(
              T.MathUtils.degToRad(e.x||0),
              T.MathUtils.degToRad(e.y||0),
              T.MathUtils.degToRad(e.z||0),
              "YXZ"
            );
          }
          this.yaw.rotation.set(0,0,0);
          this.pitch.rotation.set(0,0,0);
        }

        onInputsChanged(changed){
          if(changed.near||changed.far||changed.hfovDeg||changed.aspect) this._buildFrustum();
          if(changed.worldPosition||changed.worldRotationQuat||changed.worldEulerDeg) this._applyTransform();
        }

        onTick(dt){
          if(!this.inputs.panEnabled) return;
          const T=this.context.three, amp=T.MathUtils.degToRad(this.inputs.panAngleDeg||60);
          const omega=(2*Math.PI)/(this.inputs.panPeriodSec||8);
          this.yaw.rotation.y=Math.sin((this._t=(this._t||0)+dt)*omega)*amp;
        }
      }

      sdk.Scene.register("ark.securityCam", SecurityCam);
    }

    async function addCamAtViewer(sdk, opts = {}) {
      const pose = await sdk.Camera.getPose();
      const node = await sdk.Scene.createNode();
      const comp = node.addComponent("ark.securityCam");
      const defaults = {
        worldPosition: { ...pose.position },
        worldRotationQuat: { ...pose.rotation },
        hfovDeg: 95, aspect: 16/9, near: 0.25, far: 16,
        color: 0x00e0ff, opacity: 0.28, wireOpacity: 0.9,
        panEnabled: false
      };
      Object.assign(comp.inputs, Object.assign(defaults, opts));
      await node.start();
      return { id: node.id, node, comp };
    }

    async function addCamAhead(sdk, meters = 2, opts = {}) {
      const pose = await sdk.Camera.getPose();
      // camera forward (-Z) from quaternion
      const fwd = (q => {
        const x=2*(q.x*q.z+q.w*q.y), y=2*(q.y*q.z-q.w*q.x), z=1-2*(q.x*q.x+q.y*q.y);
        return { x:-x, y:-y, z:-z };
      })(pose.rotation);
      const wp = {
        x: pose.position.x + fwd.x * meters,
        y: pose.position.y + fwd.y * meters,
        z: pose.position.z + fwd.z * meters
      };
      return addCamAtViewer(sdk, { worldPosition: wp, ...opts });
    }

    // ---------- Wire up viewer ----------
    viewer.addEventListener('mpSdkPlaying', async (evt) => {
      try {
        const sdk = evt.detail.mpSdk;
        registerSecurityCam(sdk);

        // Add one at the viewer and one slightly ahead so it's obvious
        await addCamAtViewer(sdk, { color: 0x00ff88 });
        await addCamAhead(sdk, 2, { color: 0xffff00, opacity: 0.35 });

        const info = await sdk.Model.getData();
        badge.textContent = `SDK connected — model: ${info.sid}`;
      } catch (err) {
        console.error('SDK init error', err);
        badge.textContent = 'SDK init error (see console)';
      }
    });

    // Fallback notice if nothing happens
    setTimeout(() => {
      if (badge.textContent.startsWith('loading')) {
        console.warn('Viewer did not reach READY/PLAYING in time');
        badge.textContent = 'still loading… (check console/network)';
      }
    }, 10000);
  </script>
</body>
</html>