<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ark – Matterport (Web Component)</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#111; color:#eee; }
    matterport-viewer { display:block; inline-size:100%; block-size:100dvh; }
    .badge {
      position:absolute; left:10px; top:10px; z-index:5;
      padding:6px 10px; font:12px system-ui;
      background:rgba(0,0,0,.55); border:1px solid #333; border-radius:8px;
    }
  </style>

  <!-- Local showcase CSS -->
  <link rel="stylesheet" href="./css/showcase.css" />

  <!-- Import map (valid JSON only) -->
  <script type="importmap">
  {
    "imports": {
      "three": "./vendors/three/0.176.0/build/three.module.js",
      "three/addons/": "./vendors/three/0.176.0/examples/jsm/",
      "@matterport/webcomponent": "./vendors/matterport-webcomponent/0.1.45/matterport-viewer.esm.js"
    }
  }
  </script>
</head>
<body>
  <div class="badge" id="badge">loading…</div>

  <matterport-viewer
    m="1ghABoaBFPZ"
    application-key="akqd0dp3hr9wz4eu70zd1rsab"
    asset-base="/Ark"
    play title="false" brand="false" style="outline:0">
  </matterport-viewer>

  <script type="module">
  import "@matterport/webcomponent";

  const badge  = document.getElementById('badge');
  const viewer = document.querySelector('matterport-viewer');
  const set = (t) => (badge.textContent = t);

  const FOLLOW_CAMERA = true;
  const WEDGE_SCALE   = 0.55;
  const HEIGHT_OFFSET = 0.00;
  const AXIS_CORRECTION_EULER_DEG = [0, 0, 0]; // adjust if pointing wrong

  // --- math helpers (no THREE import needed) ---
  const V = (x=0,y=0,z=0)=>({x:+x||0,y:+y||0,z:+z||0});
  const len = (v)=>Math.hypot(v.x,v.y,v.z)||1;
  const norm = (v)=>{ const s=1/len(v); return {x:v.x*s,y:v.y*s,z:v.z*s}; };
  const dot = (a,b)=>a.x*b.x+a.y*b.y+a.z*b.z;
  const cross=(a,b)=>({x:a.y*b.z-a.z*b.y,y:a.z*b.x-a.x*b.z,z:a.x*b.y-a.y*b.x});
  const qMul=(a,b)=>({w:a.w*b.w-a.x*b.x-a.y*b.y-a.z*b.z,x:a.w*b.x+a.x*b.w+a.y*b.z-a.z*b.y,y:a.w*b.y-a.x*b.z+a.y*b.w+a.z*b.x,z:a.w*b.z+a.x*b.y-a.y*b.x+a.z*b.w});
  const qNorm=(q)=>{const s=1/Math.hypot(q.x,q.y,q.z,q.w||0);return{x:q.x*s,y:q.y*s,z:q.z*s,w:(q.w||0)*s};};
  const qFromEulerDeg=([ex,ey,ez])=>{
    const r=Math.PI/180, cx=Math.cos(ex*r/2), sx=Math.sin(ex*r/2);
    const cy=Math.cos(ey*r/2), sy=Math.sin(ey*r/2);
    const cz=Math.cos(ez*r/2), sz=Math.sin(ez*r/2);
    return {w:cx*cy*cz+sx*sy*sz,x:sx*cy*cz-cx*sy*sz,y:cx*sy*cz+sx*cy*sz,z:cx*cy*sz-sx*sy*cz};
  };
  function quatFromZTo(t){
    const a=V(0,0,1), b=norm(t); let v=cross(a,b), w=1+dot(a,b);
    if (w<1e-6){ v = Math.abs(a.z)<0.9 ? cross(a,{x:1,y:0,z:0}) : cross(a,{x:0,y:1,z:0}); w=0; }
    return qNorm({x:v.x,y:v.y,z:v.z,w});
  }

  // Use MP's own Vector3 type for Tag API
  const v3 = (sdk,x,y,z) => sdk?.Graph?.Vector3?.create ? sdk.Graph.Vector3.create(x,y,z) : {x,y,z};

  async function addCamTagFallback(sdk){
    const pose = await sdk.Camera.getPose();
    const p = v3(sdk, pose.position.x, pose.position.y, pose.position.z);
    const tryDescs = [
      { label:'Cam', description:'Fallback marker (GLB failed)', anchorPosition: p, stemVector: v3(sdk,0,0.2,0) },
      { label:'Cam', description:'Fallback marker (GLB failed)', position: p,        normal:      v3(sdk,0,1,0) }
    ];
    let last;
    for (const d of tryDescs){
      try { await sdk.Tag.add([d]); return; } catch(e){ last=e; console.warn('Tag.add failed descriptor', d, e); }
    }
    throw last;
  }

  let wedgeNode = null;
  async function placeOrUpdateWedge(sdk, pose){
    if (!wedgeNode){
      wedgeNode = await sdk.Scene.createNode();

      // Preflight the GLB to avoid cache/CORS hiccups, then feed loader an Object URL
      const bust='ark-wedge-v2';
      const glbHttpUrl = new URL(`./assets/ark-wedge.glb?${bust}`, import.meta.url).href;
      console.log('GLB URL (HTTP):', glbHttpUrl);

      const res = await fetch(glbHttpUrl, { cache: 'no-store' });
      if (!res.ok) throw new Error(`GLB fetch failed ${res.status} ${res.statusText}`);
      const blob = await res.blob();
      const objectUrl = URL.createObjectURL(blob);
      console.log('GLB URL (blob):', objectUrl);

      // Use built-in GLTF loader (factory id string works in your SDK)
      wedgeNode.addComponent('mp.gltfLoader', { url: objectUrl });
      wedgeNode.scale.set(WEDGE_SCALE, WEDGE_SCALE, WEDGE_SCALE);
      wedgeNode.start();
    }

    // Position & orientation
    wedgeNode.position.set(pose.position.x, pose.position.y + HEIGHT_OFFSET, pose.position.z);
    const f = V(pose.forward.x, pose.forward.y, pose.forward.z);
    const q = qNorm( qMul( quatFromZTo(f), qFromEulerDeg(AXIS_CORRECTION_EULER_DEG) ) );
    wedgeNode.quaternion.set(q.x, q.y, q.z, q.w);
  }

  ['mpReady','mpPlaying','mpError','mpSdkError']
    .forEach(ev => viewer.addEventListener(ev, e => console.log(`[${ev}]`, e.detail ?? null)));

  viewer.addEventListener('mpSdkPlaying', async (evt) => {
    const sdk = evt.detail?.mpSdk;
    if (!sdk) { set('SDK missing'); return; }

    try {
      const pose = await sdk.Camera.getPose();
      await placeOrUpdateWedge(sdk, pose);
      set('SDK ✓ 3D cam (GLB) added');

      if (FOLLOW_CAMERA) {
        viewer.addEventListener('mpNavigationChanged', async () => {
          try { await placeOrUpdateWedge(sdk, await sdk.Camera.getPose()); }
          catch (e) { console.warn('update wedge failed', e); }
        });
      }
    } catch (e) {
      console.warn('GLB path failed; Tag fallback', e);
      try { await addCamTagFallback(sdk); set('SDK ✓ tag added (fallback)'); }
      catch (e2) { set('SDK init error (see console)'); console.error('Tag fallback failed:', e2); }
    }
  });

  setTimeout(() => {
    if (badge.textContent.startsWith('loading')) {
      console.warn('Viewer did not reach READY/PLAYING in time');
      badge.textContent = 'still loading… (check console/network)';
    }
  }, 10000);
</script>
</body>
</html>