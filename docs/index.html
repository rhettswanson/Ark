<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Security Camera FOV in Matterport</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
  <iframe id="showcase" width="100%" height="100%" src="bundle/showcase.html?m=1ghABoaBFPZ&applicationKey=akqd0dp3hr9wz4eu70zd1rsab" frameborder="0" allowfullscreen allow="xr-spatial-tracking"></iframe>
  <script>
  (async () => {
    const showcase = document.getElementById('showcase');
    showcase.addEventListener('load', async () => {
      try {
        const mpSdk = await showcase.contentWindow.MP_SDK.connect(showcase.contentWindow);
        console.log('SDK Connected:', mpSdk);

        const THREE = showcase.contentWindow.THREE;

        mpSdk.Scene.register('mp.securityCamera', function () {
          return {
            name: 'mp.securityCamera',
            inputs: {
              nearPlane: 0.3,
              farPlane: 30.48,
              horizontalFOV: 100,
              aspect: 100 / 60,
              localPosition: { x: 38.533267551194896, y: 3.1063737842226677, z: -23.40692846848303 },
              localRotation: { x: -20, y: 0, z: 0 },
              color: 0x00ff00,
              panPeriod: 8,
              panAngle: 120
            },
            outputs: {},
            onInit: function () {
              const T = this.context.three;
              this.group = new T.Group();
              this.yaw = new T.Group();
              this.pitch = new T.Group();
              this.group.add(this.yaw);
              this.yaw.add(this.pitch);
              this.makeFrustumVisuals();
              this.outputs.objectRoot = this.group;
              this.makeAnimation();
            },
            onTick: function (delta) {
              if (this.mixer) {
                this.mixer.update(delta / 1000);
              }
            },
            onInputsUpdated: function () {
              this.makeFrustumVisuals();
            },
            onDestroy: function () {
              if (this.box) {
                this.box.geometry.dispose();
                this.box.material.dispose();
              }
              if (this.edges) {
                this.edges.geometry.dispose();
                this.edges.material.dispose();
              }
            },
            makeFrustumVisuals: function () {
              const T = this.context.three;
              if (this.box) {
                this.pitch.remove(this.box);
                this.box.geometry.dispose();
                this.box.material.dispose();
              }
              if (this.edges) {
                this.pitch.remove(this.edges);
                this.edges.geometry.dispose();
                this.edges.material.dispose();
              }
              const frustumLength = this.inputs.farPlane - this.inputs.nearPlane;
              const boxGeometry = new T.BoxGeometry(2, 2, frustumLength);
              const halfHAngle = (this.inputs.horizontalFOV * 0.5 * Math.PI) / 180;
              const nearHalfWidth = Math.tan(halfHAngle) * this.inputs.nearPlane;
              const farHalfWidth = Math.tan(halfHAngle) * this.inputs.farPlane;
              const nearHalfHeight = nearHalfWidth / this.inputs.aspect;
              const farHalfHeight = farHalfWidth / this.inputs.aspect;
              const positions = boxGeometry.attributes.position;
              for (let i = 0; i < positions.count; i++) {
                const vertexZ = positions.getZ(i);
                const vertexX = positions.getX(i);
                const vertexY = positions.getY(i);
                if (vertexZ > 0) {
                  positions.setX(i, vertexX * nearHalfWidth);
                  positions.setY(i, vertexY * nearHalfHeight);
                } else {
                  positions.setX(i, vertexX * farHalfWidth);
                  positions.setY(i, vertexY * farHalfHeight);
                }
                positions.setZ(i, vertexZ - 0.5 * frustumLength - this.inputs.nearPlane);
              }
              const boxMaterial = new T.MeshBasicMaterial({
                color: this.inputs.color,
                opacity: 0.05,
                transparent: true,
                side: T.BackSide,
                blending: T.NormalBlending,
                depthWrite: false,
              });
              this.box = new T.Mesh(boxGeometry, boxMaterial);
              const edgesGeometry = new T.EdgesGeometry(boxGeometry);
              this.edges = new T.LineSegments(edgesGeometry, new T.LineBasicMaterial({ color: 0xffffff, opacity: 0.25, transparent: true, blending: T.AdditiveBlending, depthWrite: false }));
              this.pitch.add(this.box);
              this.pitch.add(this.edges);
            },
            makeAnimation: function () {
              const T = this.context.three;
              const yAxis = new T.Vector3(0, 1, 0);
              const frame0 = new T.Quaternion().setFromAxisAngle(yAxis, 0);
              const frame1 = new T.Quaternion().setFromAxisAngle(yAxis, this.inputs.panAngle * (Math.PI / 180));
              const track = new T.QuaternionKeyframeTrack(
                '.rotation',
                [0, this.inputs.panPeriod * 0.05, this.inputs.panPeriod * 0.95, this.inputs.panPeriod],
                [
                  frame0.x, frame0.y, frame0.z, frame0.w,
                  frame0.x, frame0.y, frame0.z, frame0.w,
                  frame1.x, frame1.y, frame1.z, frame1.w,
                  frame1.x, frame1.y, frame1.z, frame1.w,
                ]
              );
              const clip = new T.AnimationClip('panning', this.inputs.panPeriod, [track]);
              this.mixer = new T.AnimationMixer(this.yaw);
              const action = this.mixer.clipAction(clip);
              action.loop = T.LoopPingPong;
              action.play();
            },
            _update: function () {
              if (this.mixer) this.mixer.update(1 / 60);
            },
            _applyTransform: function () {
              this.group.position.set(this.inputs.localPosition.x, this.inputs.localPosition.y, this.inputs.localPosition.z);
              this.group.rotation.set(this.inputs.localRotation.x, this.inputs.localRotation.y, this.inputs.localRotation.z);
            }
          };
        });

        const [sceneObject] = await mpSdk.Scene.createObjects(1);
        const node = sceneObject.addNode();

        node.addComponent('mp.securityCamera');

        node.start();

        console.log('FOV cone added!');
      } catch (e) {
        console.error('Error:', e);
      }
    });
  })();
</script>
</body>
</html>