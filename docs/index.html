<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ark – Security Cam</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#111; color:#eee; }
    matterport-viewer { display:block; inline-size:100%; block-size:100dvh; }
    .badge{
      position:absolute; left:10px; top:10px; z-index:5;
      padding:6px 10px; font:12px system-ui;
      background:rgba(0,0,0,.55); border:1px solid #333; border-radius:8px;
    }
  </style>
  <link rel="stylesheet" href="./css/showcase.css">
</head>
<body>
  <div class="badge" id="badge">loading…</div>

  <matterport-viewer
    m="1ghABoaBFPZ"
    application-key="akqd0dp3hr9wz4eu70zd1rsab"
    asset-base="/Ark"
    play
    title="false"
    brand="false"
    style="outline:0">
  </matterport-viewer>

  <!-- UMD viewer (must NOT be the ESM file) -->
  <script src="./vendors/matterport-webcomponent/0.1.45/webcomponent.js"></script>

  <script>
  const badge  = document.getElementById('badge');
  const viewer = document.querySelector('matterport-viewer');

  // --- Security Cam component (extends Matterport's base) ---
  function registerSecurityCam(sdk){
    try {
      class SecurityCam extends sdk.Scene.Component {
        onInit(){
          this.inputs = {
            color: 0x66ff99,
            opacity: 0.35,
            showFrustum: true,
            position: { x: 0, y: 1.6, z: 0 },
            lookAt:   { x: 1, y: 1.6, z: 0 }
          };
          const THREE = this.context.three;

          const markGeo = new THREE.SphereGeometry(0.06,16,12);
          const markMat = new THREE.MeshBasicMaterial({ color:this.inputs.color, transparent:true, opacity:0.9 });
          this._marker = new THREE.Mesh(markGeo, markMat);

          const coneGeo = new THREE.ConeGeometry(0.35,0.5,24,1,true);
          const coneMat = new THREE.MeshBasicMaterial({ color:this.inputs.color, wireframe:true, transparent:true, opacity:this.inputs.opacity, depthWrite:false });
          this._frustum = new THREE.Mesh(coneGeo, coneMat);
          this._frustum.rotation.x = -Math.PI/2;

          this._group = new THREE.Group();
          this._group.add(this._marker, this._frustum);
          this.context.scene.add(this._group);
        }

        onInputsUpdated(){
          if (!this._group) return;
          const p = this.inputs.position, l = this.inputs.lookAt;
          if (p) this._group.position.set(p.x,p.y,p.z);
          if (l) this._group.lookAt(l.x,l.y,l.z);
          this._frustum.visible = !!this.inputs.showFrustum;
        }

        onDestroy(){
          this._group?.parent?.remove(this._group);
          this._group = this._marker = this._frustum = null;
        }
      }

      sdk.Scene.register('ark.securityCam', SecurityCam);
      return true;
    } catch (e){
      console.error('SecurityCam register failed', e);
      return false;
    }
  }

  const log = e => console.log(`[${e.type}]`, e.detail ?? '');
  ['mpReady','mpProgress','mpCameraAvailable','mpNavigationChanged','mpError','mpSdkError']
    .forEach(t => viewer.addEventListener(t, log));

  viewer.addEventListener('mpSdkPlaying', async (evt) => {
    try{
      const sdk = evt.detail.mpSdk;

      const ok = registerSecurityCam(sdk);
      if (!ok){ badge.textContent = 'Security Cam disabled (register failed)'; return; }

      const node = await sdk.Scene.createNode();
      const comp = node.addComponent('ark.securityCam', {}); // pass a literal {}
      node.start();

      const pose = await sdk.Camera.getPose();
      comp.inputs.position = { x: pose.position.x, y: pose.position.y, z: pose.position.z };
      comp.inputs.lookAt   = {
        x: pose.position.x + pose.forward.x,
        y: pose.position.y + pose.forward.y,
        z: pose.position.z + pose.forward.z
      };

      const info = await sdk.Model.getData();
      badge.textContent = `SDK connected — model: ${info.sid}`;
    }catch(err){
      console.error('SDK init error', err);
      badge.textContent = 'SDK init error (see console)';
    }
  });

  setTimeout(() => {
    if (badge.textContent.startsWith('loading')){
      console.warn('Viewer did not reach READY/PLAYING in time');
      badge.textContent = 'still loading… (check console/network)';
    }
  }, 10000);
  </script>
</body>
</html>