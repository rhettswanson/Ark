<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ark – Matterport (Web Component)</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#111; color:#eee; }
    matterport-viewer { display:block; inline-size:100%; block-size:100dvh; }
    .badge {
      position:absolute; left:10px; top:10px; z-index:5;
      padding:6px 10px; font:12px system-ui;
      background:rgba(0,0,0,.55); border:1px solid #333; border-radius:8px;
    }
  </style>

  <!-- Local showcase CSS (no CDN) -->
  <link rel="stylesheet" href="./css/showcase.css" />

  <!-- Import map: resolve local ESM copies -->
  <script type="importmap">
  {
    "imports": {
      "three": "./vendors/three/0.176.0/build/three.module.js",
      "three/addons/": "./vendors/three/0.176.0/examples/jsm/",
      "@matterport/webcomponent": "./vendors/matterport-webcomponent/0.1.45/matterport-viewer.esm.js"
    }
  }
  </script>
</head>
<body>
  <div class="badge" id="badge">loading…</div>

  <matterport-viewer
    m="1ghABoaBFPZ"
    application-key="akqd0dp3hr9wz4eu70zd1rsab"
    asset-base="/Ark"
    play title="false" brand="false" style="outline:0">
  </matterport-viewer>

  <script type="module">
    import "@matterport/webcomponent";

    const badge  = document.getElementById('badge');
    const viewer = document.querySelector('matterport-viewer');

    // ---------- Diagnostics ----------
    const log = (e) => console.log(`[${e.type}]`, e.detail ?? '');
    ['mpReady','mpProgress','mpCameraAvailable','mpNavigationChanged','mpError','mpSdkError']
      .forEach(t => viewer.addEventListener(t, log));

    // ---------- SecurityCam Scene Component ----------
    function registerSecurityCam(sdk) {
      sdk.Scene.register("ark.securityCam", () => {
        return class SecurityCam extends sdk.Scene.Component {
          constructor(ctx) {
            super(ctx);
            this.inputs = {
              near: 0.30, far: 12.0, hfovDeg: 95, aspect: 16/9,
              color: 0xff44aa, opacity: 0.28, wireOpacity: 0.9,
              worldPosition: { x: 0, y: 2.6, z: 0 },
              worldRotationQuat: null,
              worldEulerDeg: { x: 0, y: 0, z: 0 },
              panEnabled: false, panAngleDeg: 60, panPeriodSec: 8
            };
            this.outputs = { objectRoot: null };
            this._t = 0;
          }

          onInit() {
            const T = this.context.three;

            this.root  = new T.Group();
            this.root.renderOrder = 9999; // draw late
            this.yaw   = new T.Group();
            this.pitch = new T.Group();
            this.root.add(this.yaw);
            this.yaw.add(this.pitch);

            this.material = new T.MeshBasicMaterial({
              color: this.inputs.color,
              transparent: true,
              opacity: this.inputs.opacity,
              side: T.DoubleSide,
              depthWrite: false,
              depthTest: false           // <<< keep visible on top
            });
            this.lineMat = new T.LineBasicMaterial({
              color: this.inputs.color,
              transparent: true,
              opacity: this.inputs.wireOpacity,
              depthTest: false           // <<< keep visible on top
            });

            this._buildFrustum();
            this._applyTransform();
            this.outputs.objectRoot = this.root;
          }

          _buildFrustum() {
            const T = this.context.three;
            const n=this.inputs.near, f=this.inputs.far;
            const hf=T.MathUtils.degToRad(this.inputs.hfovDeg);
            const a=this.inputs.aspect, vf=2*Math.atan(Math.tan(hf/2)/a);

            const nw=Math.tan(hf/2)*n, nh=Math.tan(vf/2)*n;
            const fw=Math.tan(hf/2)*f, fh=Math.tan(vf/2)*f;

            const V=[[-nw,nh,-n],[nw,nh,-n],[nw,-nh,-n],[-nw,-nh,-n],
                     [-fw,fh,-f],[fw,fh,-f],[fw,-fh,-f],[-fw,-fh,-f]];

            const tris=[0,1,2,0,2,3, 4,6,5,4,7,6, 0,4,5,0,5,1, 1,5,6,1,6,2,
                        2,6,7,2,7,3, 3,7,4,3,4,0];
            const tp=new Float32Array(tris.length*3);
            for(let i=0;i<tris.length;i++){const p=V[tris[i]];tp[i*3]=p[0];tp[i*3+1]=p[1];tp[i*3+2]=p[2];}
            const g=new T.BufferGeometry(); g.setAttribute("position", new T.BufferAttribute(tp,3));

            const ep=[0,1,1,2,2,3,3,0, 4,5,5,6,6,7,7,4, 0,4,1,5,2,6,3,7];
            const epos=new Float32Array(ep.length*3);
            for(let i=0;i<ep.length;i++){const p=V[ep[i]];epos[i*3]=p[0];epos[i*3+1]=p[1];epos[i*3+2]=p[2];}
            const eg=new T.BufferGeometry(); eg.setAttribute("position", new T.BufferAttribute(epos,3));

            if(!this.mesh){
              this.mesh=new T.Mesh(g,this.material);
              this.wire=new T.LineSegments(eg,this.lineMat);
              this.pitch.add(this.mesh,this.wire);
            }else{
              this.mesh.geometry?.dispose(); this.wire.geometry?.dispose();
              this.mesh.geometry=g; this.wire.geometry=eg;
            }
          }

          _applyTransform() {
            const T=this.context.three;
            this.root.position.set(this.inputs.worldPosition.x,this.inputs.worldPosition.y,this.inputs.worldPosition.z);
            if(this.inputs.worldRotationQuat && "x" in this.inputs.worldRotationQuat){
              const q=this.inputs.worldRotationQuat;
              this.root.quaternion.set(q.x,q.y,q.z,q.w);
            } else {
              const e=this.inputs.worldEulerDeg;
              this.root.rotation.set(
                T.MathUtils.degToRad(e.x||0),
                T.MathUtils.degToRad(e.y||0),
                T.MathUtils.degToRad(e.z||0),
                "YXZ"
              );
            }
            this.yaw.rotation.set(0,0,0);
            this.pitch.rotation.set(0,0,0);
          }

          onInputsChanged(changed){
            if(changed.near||changed.far||changed.hfovDeg||changed.aspect) this._buildFrustum();
            if(changed.worldPosition||changed.worldRotationQuat||changed.worldEulerDeg) this._applyTransform();
          }

          onTick(dt){
            if(!this.inputs.panEnabled) return;
            const T=this.context.three, amp=T.MathUtils.degToRad(this.inputs.panAngleDeg||60);
            const omega=(2*Math.PI)/(this.inputs.panPeriodSec||8);
            this.yaw.rotation.y=Math.sin((this._t+=dt)*omega)*amp;
          }
        };
      });
    }

    // Place a camera at current viewer pose
    async function addCamAtViewer(sdk, opts = {}) {
      const pose = await sdk.Camera.getPose();
      const node = await sdk.Scene.createNode();
      const comp = node.addComponent("ark.securityCam");
      const defaults = {
        worldPosition: { ...pose.position },
        worldRotationQuat: { ...pose.rotation },
        hfovDeg: 95, aspect: 16/9, near: 0.25, far: 16,
        color: 0xff44aa, opacity: 0.28, wireOpacity: 0.9,
        panEnabled: false
      };
      Object.assign(comp.inputs, Object.assign(defaults, opts));
      await node.start();
      console.log("security cam added", node.id);
      badge.textContent = `SDK connected — cam ${node.id} added`;
      return { id: node.id, node, comp };
    }

    // Helper: cam 2m in front of the current camera
    async function addCamAhead(sdk, meters = 2, opts = {}) {
      const pose = await sdk.Camera.getPose();
      // forward vector from rotation quaternion (camera -Z in world space)
      const fwd = (q => {
        const x=2*(q.x*q.z+q.w*q.y), y=2*(q.y*q.z-q.w*q.x), z=1-2*(q.x*q.x+q.y*q.y);
        return { x:-x, y:-y, z:-z }; // camera forward points -Z
      })(pose.rotation);
      const wp = {
        x: pose.position.x + fwd.x * meters,
        y: pose.position.y + fwd.y * meters,
        z: pose.position.z + fwd.z * meters
      };
      return addCamAtViewer(sdk, { worldPosition: wp, ...opts });
    }

    let lastCam = null;

    viewer.addEventListener('mpSdkPlaying', async (evt) => {
      try {
        const sdk = evt.detail.mpSdk;
        registerSecurityCam(sdk);

        // Add two frusta so one is easy to spot immediately
        lastCam = await addCamAtViewer(sdk, { color: 0x00e0ff });
        await addCamAhead(sdk, 2, { color: 0xffff00, opacity: 0.35 });

        const info = await sdk.Model.getData();
        console.log('pose', await sdk.Camera.getPose());
        badge.textContent = `SDK connected — model: ${info.sid}  (press C to add cam, P to pan)`;

        // Hotkeys
        window.addEventListener('keydown', async (e) => {
          if (e.key.toLowerCase() === 'c') {
            lastCam = await addCamAtViewer(sdk, { color: 0x00ff88 });
          } else if (e.key.toLowerCase() === 'p' && lastCam?.comp) {
            lastCam.comp.inputs.panEnabled = !lastCam.comp.inputs.panEnabled;
            console.log('panEnabled:', lastCam.comp.inputs.panEnabled);
          }
        });
      } catch (err) {
        console.error('SDK init error', err);
        badge.textContent = 'SDK init error (see console)';
      }
    });

    // Inform if nothing happens
    setTimeout(() => {
      if (badge.textContent.startsWith('loading')) {
        console.warn('Viewer did not reach READY/PLAYING in time');
        badge.textContent = 'still loading… (check console/network)';
      }
    }, 10000);
  </script>
</body>
</html>