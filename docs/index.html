<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ark – Matterport (Web Component)</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#111; color:#eee; }
    matterport-viewer { display:block; inline-size:100%; block-size:100dvh; }
    .badge { position:absolute; left:10px; top:10px; z-index:5;
      padding:6px 10px; font:12px system-ui;
      background:rgba(0,0,0,.55); border:1px solid #333; border-radius:8px; }
  </style>
</head>
<body>
  <div class="badge" id="badge">loading…</div>

  <matterport-viewer
    m="1ghABoaBFPZ"
    application-key="akqd0dp3hr9wz4eu70zd1rsab"
    asset-base="/Ark/mp-assets"
    play
    title="false"
    brand="false"
    style="outline:0"
  ></matterport-viewer>

  <script type="module">
    import "https://esm.sh/@matterport/webcomponent@0.1.45?deps=three@0.176.0";

    const badge  = document.getElementById("badge");
    const viewer = document.querySelector("matterport-viewer");

    viewer.addEventListener("mpSdkPlaying", async (evt) => {
      try {
        const sdk = evt.detail.mpSdk;

        const info = await sdk.Model.getData();
        badge.textContent = `SDK connected — model: ${info.sid}`;
        console.log("pose", await sdk.Camera.getPose());

        // ---- register component as object literal (now with outputs stub) ----
        sdk.Scene.register("ark.securityCam", () => {
          const inputs = {
            near: 0.3,
            far: 12.0,
            hfovDeg: 90,
            aspect: 16/9,
            color: 0x00aaff,
            opacity: 0.18,
            wireOpacity: 0.6,
            worldPosition: { x: 0, y: 2.6, z: 0 },
            worldEulerDeg: { x: 0, y: 0, z: 0 },
            worldRotationQuat: { x: 0, y: 0, z: 0, w: 1 },
            panEnabled: false,
            panAngleDeg: 60,
            panPeriodSec: 8,
          };

          let root, yaw, pitch, mesh, wire, material, lineMat;
          let tAccum = 0;

          function buildFrustum(ctx, inp) {
            const T  = ctx.three;
            const n  = inp.near, f = inp.far;
            const hf = T.MathUtils.degToRad(inp.hfovDeg);
            const a  = inp.aspect;
            const vf = 2 * Math.atan(Math.tan(hf/2) / a);

            const nw = Math.tan(hf/2) * n, nh = Math.tan(vf/2) * n;
            const fw = Math.tan(hf/2) * f, fh = Math.tan(vf/2) * f;

            const V = [
              [-nw,  nh, -n], [ nw,  nh, -n], [ nw, -nh, -n], [-nw, -nh, -n],
              [-fw,  fh, -f], [ fw,  fh, -f], [ fw, -fh, -f], [-fw, -fh, -f],
            ];
            const idx = [
              0,1,2, 0,2,3,
              4,6,5, 4,7,6,
              0,4,5, 0,5,1,
              1,5,6, 1,6,2,
              2,6,7, 2,7,3,
              3,7,4, 3,4,0,
            ];

            const pos = new Float32Array(idx.length * 3);
            for (let i=0;i<idx.length;i++){ const p = V[idx[i]]; pos[i*3]=p[0]; pos[i*3+1]=p[1]; pos[i*3+2]=p[2]; }
            const g = new T.BufferGeometry();
            g.setAttribute("position", new T.BufferAttribute(pos, 3));

            const edges = [0,1,1,2,2,3,3,0, 4,5,5,6,6,7,7,4, 0,4,1,5,2,6,3,7];
            const epos = new Float32Array(edges.length * 3);
            for (let i=0;i<edges.length;i++){ const p = V[edges[i]]; epos[i*3]=p[0]; epos[i*3+1]=p[1]; epos[i*3+2]=p[2]; }
            const eg = new T.BufferGeometry();
            eg.setAttribute("position", new T.BufferAttribute(epos, 3));

            if (!mesh) {
              mesh = new T.Mesh(g, material);
              wire = new T.LineSegments(eg, lineMat);
              pitch.add(mesh, wire);
            } else {
              mesh.geometry?.dispose(); wire.geometry?.dispose();
              mesh.geometry = g; wire.geometry = eg;
            }
          }

          function applyTransform(ctx, inp) {
            const T = ctx.three;
            root.position.set(inp.worldPosition.x, inp.worldPosition.y, inp.worldPosition.z);

            const q = inp.worldRotationQuat;
            if (q && typeof q.x === "number") {
              root.quaternion.set(q.x, q.y, q.z, q.w);
            } else {
              const e = inp.worldEulerDeg;
              root.rotation.set(
                T.MathUtils.degToRad(e.x||0),
                T.MathUtils.degToRad(e.y||0),
                T.MathUtils.degToRad(e.z||0),
                "YXZ"
              );
            }
            yaw.rotation.set(0,0,0);
            pitch.rotation.set(0,0,0);
          }

          return {
            inputs,
            /** IMPORTANT: predefine outputs so the proxy doesn’t hit undefined */
            outputs: { objectRoot: null },

            onInit() {
              const T = this.context.three;
              root  = new T.Group();
              yaw   = new T.Group();
              pitch = new T.Group();
              root.add(yaw); yaw.add(pitch);

              material = new T.MeshBasicMaterial({
                color: inputs.color, transparent:true, opacity: inputs.opacity,
                depthWrite:false, side:T.DoubleSide
              });
              lineMat = new T.LineBasicMaterial({
                color: inputs.color, transparent:true, opacity: inputs.wireOpacity
              });

              buildFrustum(this.context, inputs);
              applyTransform(this.context, inputs);

              this.outputs.objectRoot = root;
            },

            onInputsChanged(changed) {
              if (changed.near || changed.far || changed.hfovDeg || changed.aspect) {
                buildFrustum(this.context, this.inputs);
              }
              if (changed.worldPosition || changed.worldRotationQuat || changed.worldEulerDeg) {
                applyTransform(this.context, this.inputs);
              }
              if (changed.color || changed.opacity || changed.wireOpacity) {
                material.color.set(this.inputs.color);
                material.opacity = this.inputs.opacity;
                lineMat.color.set(this.inputs.color);
                lineMat.opacity = this.inputs.wireOpacity;
              }
            },

            onTick(dt) {
              if (!this.inputs.panEnabled) return;
              const T = this.context.three;
              tAccum += dt;
              const amp   = T.MathUtils.degToRad(this.inputs.panAngleDeg||60);
              const omega = (2*Math.PI)/(this.inputs.panPeriodSec||8);
              yaw.rotation.y = Math.sin(tAccum * omega) * amp;
            }
          };
        });
        // ---- end registration ----

        async function addCamAtViewer(hfov = 90) {
          const pose = await sdk.Camera.getPose();
          const node = await sdk.Scene.createNode();
          const comp = node.addComponent("ark.securityCam");

          const pos = { ...pose.position };
          const rot = { ...pose.rotation };
          const updates = {
            worldPosition: pos,
            worldRotationQuat: rot,
            hfovDeg: hfov,
            aspect: 16/9,
            near: 0.3,
            far: 12,
            color: 0x00aaff,
            opacity: 0.18,
            wireOpacity: 0.6,
            panEnabled: false,
          };

          if (comp.inputs?.set) comp.inputs.set(updates);
          else Object.assign(comp.inputs, updates);

          await node.start();
          console.log("security cam added", node.id);
          return node.id;
        }

        await addCamAtViewer(90);
        window.addCamAtViewer = addCamAtViewer;

      } catch (err) {
        console.error(err);
        badge.textContent = "SDK init failed (see console)";
      }
    });
  </script>
</body>
</html>