<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ark – Matterport (Web Component)</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#111; color:#eee; }
    matterport-viewer { display:block; inline-size:100%; block-size:100dvh; }
    .badge { position:absolute; left:10px; top:10px; z-index:5;
      padding:6px 10px; font:12px system-ui;
      background:rgba(0,0,0,.55); border:1px solid #333; border-radius:8px; }
  </style>
</head>
<body>
  <div class="badge" id="badge">loading…</div>

  <matterport-viewer
    m="1ghABoaBFPZ"
    application-key="akqd0dp3hr9wz4eu70zd1rsab"
    asset-base="/Ark/mp-assets"
    play
    title="false"
    brand="false"
    style="outline:0"
  ></matterport-viewer>

  <script type="module">
  import "https://esm.sh/@matterport/webcomponent@0.1.45?deps=three@0.176.0";

  const badge  = document.getElementById("badge");
  const viewer = document.querySelector("matterport-viewer");

  viewer.addEventListener("mpSdkPlaying", async (evt) => {
    try {
      const mpSdk = evt.detail.mpSdk;

      const info = await mpSdk.Model.getData();
      badge.textContent = `SDK connected — model: ${info.sid}`;
      const pose = await mpSdk.Camera.getPose();
      console.log("pose", pose);

      const sdk = mpSdk;

      // ---------- SecurityCam component (with static schema) ----------
      sdk.Scene.register("ark.securityCam", () => {
        return class SecurityCam extends sdk.Scene.Component {
          // Back-compat: older Graph API reads a "schema.inputs" object
          // with { type, default } descriptors.
          static schema = {
            inputs: {
              near:              { type: "number",  default: 0.30 },
              far:               { type: "number",  default: 12.0 },
              hfovDeg:           { type: "number",  default: 90 },
              aspect:            { type: "number",  default: 16/9 },
              color:             { type: "number",  default: 0x00ff88 },
              opacity:           { type: "number",  default: 0.15 },
              wireOpacity:       { type: "number",  default: 0.55 },
              worldPosition:     { type: "vec3",    default: { x: 0, y: 2.6, z: 0 } },
              worldRotationQuat: { type: "quat",    default: { x:0, y:0, z:0, w:1 } },
              worldEulerDeg:     { type: "vec3",    default: { x: 0, y: 0, z: 0 } },
              panEnabled:        { type: "boolean", default: false },
              panAngleDeg:       { type: "number",  default: 60 },
              panPeriodSec:      { type: "number",  default: 8 }
            }
          };

          // helper that works with both old/new input proxies
          _get(name) {
            const i = this.inputs;
            if (i && typeof i.get === "function") return i.get(name);
            if (i && name in i) return i[name];
            // final fallback to schema default (first frame before proxies ready)
            const s = this.constructor.schema?.inputs?.[name];
            return s?.default;
          }

          onInit() {
            const T = this.context.three;

            this.root  = new T.Group();
            this.yaw   = new T.Group();
            this.pitch = new T.Group();
            this.root.add(this.yaw);
            this.yaw.add(this.pitch);

            this.material = new T.MeshBasicMaterial({
              color: this._get("color"),
              transparent: true,
              opacity: this._get("opacity"),
              depthWrite: false,
              side: T.DoubleSide
            });
            this.lineMat = new T.LineBasicMaterial({
              color: this._get("color"),
              transparent: true,
              opacity: this._get("wireOpacity")
            });

            this._buildFrustum();
            this._applyTransform();

            this.outputs.objectRoot = this.root;
            this._t = 0;
          }

          _buildFrustum() {
            const T = this.context.three;
            const n  = this._get("near");
            const f  = this._get("far");
            const hf = T.MathUtils.degToRad(this._get("hfovDeg"));
            const a  = this._get("aspect");
            const vf = 2 * Math.atan(Math.tan(hf/2) / a);

            const nw = Math.tan(hf/2) * n, nh = Math.tan(vf/2) * n;
            const fw = Math.tan(hf/2) * f, fh = Math.tan(vf/2) * f;

            const V = [
              [-nw,  nh, -n], [ nw,  nh, -n], [ nw, -nh, -n], [-nw, -nh, -n],
              [-fw,  fh, -f], [ fw,  fh, -f], [ fw, -fh, -f], [-fw, -fh, -f],
            ];
            const idx = [
              0,1,2, 0,2,3,  4,6,5, 4,7,6,
              0,4,5, 0,5,1,  1,5,6, 1,6,2,
              2,6,7, 2,7,3,  3,7,4, 3,4,0,
            ];

            const pos = new Float32Array(idx.length * 3);
            for (let i=0;i<idx.length;i++){
              const p = V[idx[i]];
              pos[i*3+0]=p[0]; pos[i*3+1]=p[1]; pos[i*3+2]=p[2];
            }
            const g = new T.BufferGeometry();
            g.setAttribute("position", new T.BufferAttribute(pos, 3));

            // edges
            const edgePairs = [0,1,1,2,2,3,3,0, 4,5,5,6,6,7,7,4, 0,4,1,5,2,6,3,7];
            const epos = new Float32Array(edgePairs.length * 3);
            for (let i=0;i<edgePairs.length;i++){
              const p = V[edgePairs[i]];
              epos[i*3+0]=p[0]; epos[i*3+1]=p[1]; epos[i*3+2]=p[2];
            }
            const eg = new T.BufferGeometry();
            eg.setAttribute("position", new T.BufferAttribute(epos, 3));

            if (!this.mesh) {
              this.mesh = new T.Mesh(g, this.material);
              this.wire = new T.LineSegments(eg, this.lineMat);
              this.pitch.add(this.mesh, this.wire);
            } else {
              this.mesh.geometry?.dispose();
              this.wire.geometry?.dispose();
              this.mesh.geometry = g;
              this.wire.geometry = eg;
            }
          }

          _applyTransform() {
            const T = this.context.three;
            const wp = this._get("worldPosition");
            const q  = this._get("worldRotationQuat");
            const e  = this._get("worldEulerDeg");

            this.root.position.set(wp.x, wp.y, wp.z);

            if (q && typeof q === "object" && "w" in q) {
              this.root.quaternion.set(q.x, q.y, q.z, q.w);
            } else {
              this.root.rotation.set(
                T.MathUtils.degToRad(e.x || 0),
                T.MathUtils.degToRad(e.y || 0),
                T.MathUtils.degToRad(e.z || 0),
                "YXZ"
              );
            }
            this.yaw.rotation.set(0,0,0);
            this.pitch.rotation.set(0,0,0);
          }

          onInputsChanged() {
            this._buildFrustum();
            this._applyTransform();
          }

          onTick(dt) {
            if (!this._get("panEnabled")) return;
            const T = this.context.three;
            this._t += dt;
            const amp = T.MathUtils.degToRad(this._get("panAngleDeg") || 60);
            const omega = (2*Math.PI)/(this._get("panPeriodSec") || 8);
            this.yaw.rotation.y = Math.sin(this._t * omega) * amp;
          }
        };
      });

      // helper: add one at the viewer's current pose (Scene.add or Graph fallback)
      async function addCamAtViewer(hfov = 90) {
        const pose = await sdk.Camera.getPose();
        const inputs = {
          worldPosition: pose.position,
          worldRotationQuat: pose.rotation,
          hfovDeg: hfov,
          aspect: 16/9,
          near: 0.3,
          far: 12,
          color: 0x00aaff,
          opacity: 0.18,
          wireOpacity: 0.6,
          panEnabled: false
        };

        if (sdk.Scene && typeof sdk.Scene.add === "function") {
          const id = await sdk.Scene.add("ark.securityCam", inputs);
          console.log("security cam added (add):", id);
          return id;
        }

        if (sdk.Scene && typeof sdk.Scene.createNode === "function") {
          const node = await sdk.Scene.createNode();
          const comp = node.addComponent("ark.securityCam");

          // On some builds inputs is a proxy with set(); on others it's a plain object.
          if (comp?.inputs?.set) comp.inputs.set(inputs);
          else if (comp?.inputs) Object.assign(comp.inputs, inputs);

          await node.start();
          console.log("security cam added (node):", node);
          return comp || node;
        }

        throw new Error("Scene API not available on this SDK build");
      }

      await addCamAtViewer(90);
      window.addCamAtViewer = addCamAtViewer;

    } catch (err) {
      console.error(err);
      badge.textContent = "SDK init failed (see console)";
    }
  });

  viewer.addEventListener("error", (e) => {
    console.error("Matterport webcomponent error:", e);
    badge.textContent = "viewer error (see console)";
  });
</script>
</body>
</html>