<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Security Camera FOV in Matterport</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
  <iframe id="showcase" width="100%" height="100%" src="bundle/showcase.html?m=1ghABoaBFPZ&applicationKey=akqd0dp3hr9wz4eu70zd1rsab" frameborder="0" allowfullscreen allow="xr-spatial-tracking"></iframe>
  <script>
  (async () => {
    const showcase = document.getElementById('showcase');
    showcase.addEventListener('load', async () => {
      try {
        const mpSdk = await showcase.contentWindow.MP_SDK.connect(showcase.contentWindow);
        console.log('SDK Connected:', mpSdk);

        // Log position on click (keep for future adjustments)
        mpSdk.Pointer.intersection.subscribe(intersection => console.log('Click Position:', intersection.position, 'Normal:', intersection.normal));

        const THREE = showcase.contentWindow.THREE;

        mpSdk.Scene.register('custom.securityCamera', function () {
          return {
            name: 'custom.securityCamera',
            inputs: {
              visible: true,
              nearPlane: 0.3,
              farPlane: 30.48, // 100 feet
              horizontalFOV: 100, // degrees
              aspect: 100 / 60, // Assume vertical 60°
              localPosition: { x: 45.46922907434792, y: 3.89746607269742, z: -9.821637249296977 },
              localRotation: { x: -20, y: 0, z: 0 }, // Tilt down 20°, adjust as needed
              color: 0x00ff00, // Green
              panEnabled: true,
              panAngleDeg: 120,
              panPeriodSec: 8
            },
            outputs: {},
            onInit: function () {
              const T = this.context.three;
              this.group = new T.Group();
              this.yaw = new T.Group();
              this.pitch = new T.Group();
              this.group.add(this.yaw);
              this.yaw.add(this.pitch);
              this._buildFrustum();
              this.outputs.objectRoot = this.group;
              this._applyTransform();
              this._makeAnimation();
            },
            onEvent: function (event) {
              if (event === mpSdk.Scene.SceneEventType.UPDATE) {
                this._update();
              }
            },
            onInputsUpdated: function () {
              this._rebuildFrustum();
              this._applyTransform();
            },
            onDestroy: function () {
              this.mesh.geometry.dispose();
              this.mesh.material.dispose();
              this.footprint.geometry.dispose();
              this.footprint.material.dispose();
            },
            _buildFrustum: function () {
              const T = this.context.three;
              const hFov = this.inputs.horizontalFOV * (Math.PI / 180);
              const aspect = this.inputs.aspect;
              const near = this.inputs.nearPlane;
              const far = Math.max(near + 0.01, this.inputs.farPlane);
              const nearR = Math.tan(hFov / 2) * near;
              const farR = Math.tan(hFov / 2) * far;
              const geom = new T.CylinderGeometry(nearR, farR, far - near, 48, 1, true);
              geom.translate(0, (far - near) / 2, 0);
              geom.rotateX(Math.PI / 2);
              const mat = new T.MeshBasicMaterial({
                color: this.inputs.color,
                transparent: true,
                opacity: 0.35,
                depthWrite: false
              });
              const frustum = new T.Mesh(geom, mat);
              frustum.scale.x = aspect;
              this.mesh = frustum;
              const footprint = new T.LineLoop(
                new T.CircleGeometry(farR * aspect, 64),
                new T.LineBasicMaterial({ color: this.inputs.color, transparent: true, opacity: 0.25 })
              );
              footprint.position.y = far;
              footprint.rotation.x = Math.PI / 2;
              this.pitch.add(this.mesh);
              this.pitch.add(footprint);
            },
            _rebuildFrustum: function () {
              this.pitch.remove(this.mesh);
              this.pitch.remove(this.footprint);
              this._buildFrustum();
            },
            _update: function () {
              this._t += 1 / 60; // assume 60fps
              const angle = this.inputs.panAngle * (Math.PI / 180);
              const period = this.inputs.panPeriod;
              this.yaw.rotation.y = Math.sin(this._t * (2 * Math.PI / period)) * (angle / 2);
            },
            _applyTransform: function () {
              this.group.position.set(this.inputs.localPosition.x, this.inputs.localPosition.y, this.inputs.localPosition.z);
              this.group.rotation.set(this.inputs.localRotation.x, this.inputs.localRotation.y, this.inputs.localRotation.z);
            },
            _makeAnimation: function () {
              const T = this.context.three;
              const yAxis = new T.Vector3(0, 1, 0);
              const frame0 = new T.Quaternion().setFromAxisAngle(yAxis, 0);
              const frame1 = new T.Quaternion().setFromAxisAngle(yAxis, this.inputs.panAngle * (Math.PI / 180));
              const track = new T.QuaternionKeyframeTrack(
                '.rotation',
                [0, this.inputs.panPeriod * 0.05, this.inputs.panPeriod * 0.95, this.inputs.panPeriod],
                [
                  frame0.x, frame0.y, frame0.z, frame0.w,
                  frame0.x, frame0.y, frame0.z, frame0.w,
                  frame1.x, frame1.y, frame1.z, frame1.w,
                  frame1.x, frame1.y, frame1.z, frame1.w,
                ]
              );
              const clip = new T.AnimationClip('panning', this.inputs.panPeriod, [track]);
              this.mixer = new T.AnimationMixer(this.yaw);
              const action = this.mixer.clipAction(clip);
              action.loop = T.LoopPingPong;
              action.play();
            }
          };
        });

        const [sceneObject] = await mpSdk.Scene.createObjects(1);
        const node = sceneObject.addNode();

        node.addComponent('custom.securityCamera');

        node.start();

        console.log('FOV cone added!');
      } catch (e) {
        console.error('Error:', e);
      }
    });
  })();
</script>
</body>
</html>