<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Security Camera FOV in Matterport</title>
  <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
  <iframe id="showcase" width="100%" height="100%" src="bundle/showcase.html?m=1ghABoaBFPZ&applicationKey=akqd0dp3hr9wz4eu70zd1rsab" frameborder="0" allowfullscreen allow="xr-spatial-tracking"></iframe>
  <script>
  (async () => {
    const showcase = document.getElementById('showcase');
    showcase.addEventListener('load', async () => {
      try {
        const mpSdk = await showcase.contentWindow.MP_SDK.connect(showcase.contentWindow);
        console.log('SDK Connected:', mpSdk);

        const THREE = showcase.contentWindow.THREE;

        mpSdk.Scene.register('custom.securityCamera', function () {
          return {
            name: 'custom.securityCamera',
            inputs: {
              visible: true,
              fov: 90 * (Math.PI / 180), // Horizontal FOV in radians
              aspect: 1.5, // Adjust for your cam (width/height)
              range: 10, // Max range in meters
            },
            outputs: {},
            onInit: function () {
              const T = this.context.three;

              this.group = new T.Group(); // Initialize this.group

              this.yaw = new T.Group();
              this.pitch = new T.Group();

              this.group.add(this.yaw);
              this.yaw.add(this.pitch);

              // Build the frustum lines
              this.lines = new T.LineSegments(
                new T.BufferGeometry(),
                new T.LineBasicMaterial({ color: 0xffff00, opacity: 0.5, transparent: true })
              );
              this.pitch.add(this.lines);

              this._updateFrustum();

              this.outputs.objectRoot = this.group; // Attach to outputs
            },
            onEvent: function (event) {
              if (event === mpSdk.Scene.SceneEventType.UPDATE) {
                this.lines.visible = this.inputs.visible;
              }
            },
            onInputsUpdated: function () {
              this._updateFrustum();
            },
            onDestroy: function () {
              this.lines.geometry.dispose();
              this.lines.material.dispose();
            },
            _updateFrustum: function () {
              const fov = this.inputs.fov;
              const aspect = this.inputs.aspect;
              const range = this.inputs.range;

              const halfFov = fov / 2;
              const halfHeight = Math.tan(halfFov) * range;
              const halfWidth = halfHeight * aspect;

              const positions = new Float32Array([
                0, 0, 0, -halfWidth, -halfHeight, -range,
                0, 0, 0, -halfWidth, halfHeight, -range,
                0, 0, 0, halfWidth, halfHeight, -range,
                0, 0, 0, halfWidth, -halfHeight, -range,
                -halfWidth, -halfHeight, -range, -halfWidth, halfHeight, -range,
                -halfWidth, halfHeight, -range, halfWidth, halfHeight, -range,
                halfWidth, halfHeight, -range, halfWidth, -halfHeight, -range,
                halfWidth, -halfHeight, -range, -halfWidth, -halfHeight, -range,
              ]);

              this.lines.geometry.setAttribute('position', new T.BufferAttribute(positions, 3));
            },
          };
        });

        const [sceneObject] = await mpSdk.Scene.createObjects(1);
        const node = sceneObject.addNode();

        node.addComponent('custom.securityCamera', {
          visible: true,
          fov: 90 * (Math.PI / 180),
          aspect: 1.5,
          range: 10
        });

        // Use object assignment to avoid 'set' method
        node.position = { x: 0, y: 1.5, z: 0 };
        node.rotation = { x: THREE.MathUtils.degToRad(-90), y: 0, z: 0 };

        node.start();

        console.log('FOV frustum added!');
      } catch (e) {
        console.error('Error:', e);
      }
    });
  })();
</script>
</body>
</html>